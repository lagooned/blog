{"pageProps":{"postData":{"id":"topological-sort-graph","contentHtml":"<p>hey yall! my interview prep journey knows no bounds, and good thing because it's infinite content. <a href=\"https://en.wikipedia.org/wiki/Depth-first_search\"><strong>depth-first search</strong></a> (commonly shortified as <em>dfs</em>) is a pervasive concept in computer science and offers good insight and introduction into the analysis of graphs. one particular application of depth-first search of a <a href=\"https://en.wikipedia.org/wiki/Directed_acyclic_graph\"><strong>directed acyclic graph</strong></a> (or <em>dag</em> for short) caught my interest, that being <strong>topological sort</strong>.</p>\n<h1>topsort</h1>\n<p>the topological sort of a dag is an ordering of all its vertex labels which satisfies the following statement:</p>\n<p><code>for all vertex v in any dag, there exists an ordering in which v occurs *after* the set of vertices that v directs to</code></p>\n<p>so in the following graph:</p>\n<p><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100%\" height=\"100%\" viewBox=\"0.00 0.00 206.00 188.00\"><g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 184)\"><title>G</title>\n<polygon fill=\"#000000\" stroke=\"transparent\" points=\"-4,4 -4,-184 202,-184 202,4 -4,4\"/>\n<g id=\"node1\" class=\"node\"><ellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"171\" cy=\"-162\" rx=\"27\" ry=\"18\"/><text text-anchor=\"middle\" x=\"171\" y=\"-157.8\" font-size=\"14.00\" fill=\"#FFFFFF\">3</text></g>\n<g id=\"node2\" class=\"node\"><ellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"107\" cy=\"-90\" rx=\"27\" ry=\"18\"/><text text-anchor=\"middle\" x=\"107\" y=\"-85.8\" font-size=\"14.00\" fill=\"#FFFFFF\">8</text></g>\n<g id=\"edge1\" class=\"edge\"><path fill=\"none\" stroke=\"#FFFFFF\" d=\"M157.113,-146.3771C148.4747,-136.659 137.2107,-123.987 127.5503,-113.1191\"/><polygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"130.1196,-110.7413 120.8599,-105.5924 124.8877,-115.3918 130.1196,-110.7413\"/></g>\n<g id=\"node3\" class=\"node\"><ellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"171\" cy=\"-18\" rx=\"27\" ry=\"18\"/><text text-anchor=\"middle\" x=\"171\" y=\"-13.8\" font-size=\"14.00\" fill=\"#FFFFFF\">10</text></g>\n<g id=\"edge2\" class=\"edge\"><path fill=\"none\" stroke=\"#FFFFFF\" d=\"M171,-143.7623C171,-119.201 171,-75.2474 171,-46.3541\"/><polygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"174.5001,-46.0896 171,-36.0896 167.5001,-46.0897 174.5001,-46.0896\"/></g>\n<g id=\"node7\" class=\"node\"><ellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"99\" cy=\"-18\" rx=\"27\" ry=\"18\"/><text text-anchor=\"middle\" x=\"99\" y=\"-13.8\" font-size=\"14.00\" fill=\"#FFFFFF\">9</text></g>\n<g id=\"edge6\" class=\"edge\"><path fill=\"none\" stroke=\"#FFFFFF\" d=\"M104.9813,-71.8314C104.1257,-64.131 103.1083,-54.9743 102.1574,-46.4166\"/><polygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"105.6289,-45.9656 101.0459,-36.4133 98.6717,-46.7386 105.6289,-45.9656\"/></g>\n<g id=\"node4\" class=\"node\"><ellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"27\" cy=\"-162\" rx=\"27\" ry=\"18\"/><text text-anchor=\"middle\" x=\"27\" y=\"-157.8\" font-size=\"14.00\" fill=\"#FFFFFF\">5</text></g>\n<g id=\"node5\" class=\"node\"><ellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"35\" cy=\"-90\" rx=\"27\" ry=\"18\"/><text text-anchor=\"middle\" x=\"35\" y=\"-85.8\" font-size=\"14.00\" fill=\"#FFFFFF\">11</text></g>\n<g id=\"edge3\" class=\"edge\"><path fill=\"none\" stroke=\"#FFFFFF\" d=\"M29.0187,-143.8314C29.8743,-136.131 30.8917,-126.9743 31.8426,-118.4166\"/><polygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"35.3283,-118.7386 32.9541,-108.4133 28.3711,-117.9656 35.3283,-118.7386\"/></g>\n<g id=\"edge9\" class=\"edge\"><path fill=\"none\" stroke=\"#FFFFFF\" d=\"M56.25,-78.75C78.8722,-66.7735 114.8739,-47.7138 140.516,-34.1386\"/><polygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"142.2501,-37.1808 149.4504,-29.4086 138.9749,-30.9943 142.2501,-37.1808\"/></g>\n<g id=\"edge8\" class=\"edge\"><path fill=\"none\" stroke=\"#FFFFFF\" d=\"M48.887,-74.3771C57.5253,-64.659 68.7893,-51.987 78.4497,-41.1191\"/><polygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"81.1123,-43.3918 85.1401,-33.5924 75.8804,-38.7413 81.1123,-43.3918\"/></g>\n<g id=\"node8\" class=\"node\"><ellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"27\" cy=\"-18\" rx=\"27\" ry=\"18\"/><text text-anchor=\"middle\" x=\"27\" y=\"-13.8\" font-size=\"14.00\" fill=\"#FFFFFF\">2</text></g>\n<g id=\"edge7\" class=\"edge\"><path fill=\"none\" stroke=\"#FFFFFF\" d=\"M32.9813,-71.8314C32.1257,-64.131 31.1083,-54.9743 30.1574,-46.4166\"/><polygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"33.6289,-45.9656 29.0459,-36.4133 26.6717,-46.7386 33.6289,-45.9656\"/></g>\n<g id=\"node6\" class=\"node\"><ellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"99\" cy=\"-162\" rx=\"27\" ry=\"18\"/><text text-anchor=\"middle\" x=\"99\" y=\"-157.8\" font-size=\"14.00\" fill=\"#FFFFFF\">7</text></g>\n<g id=\"edge4\" class=\"edge\"><path fill=\"none\" stroke=\"#FFFFFF\" d=\"M101.0187,-143.8314C101.8743,-136.131 102.8917,-126.9743 103.8426,-118.4166\"/><polygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"107.3283,-118.7386 104.9541,-108.4133 100.3711,-117.9656 107.3283,-118.7386\"/></g>\n<g id=\"edge5\" class=\"edge\"><path fill=\"none\" stroke=\"#FFFFFF\" d=\"M85.113,-146.3771C76.4747,-136.659 65.2107,-123.987 55.5503,-113.1191\"/><polygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"58.1196,-110.7413 48.8599,-105.5924 52.8877,-115.3918 58.1196,-110.7413\"/></g></p>\n<p>there exist multiple orderings which satisfy a topological sort, one such being:</p>\n<p><code>[3, 5, 7, 8, 11, 2, 9, 10]</code></p>\n<p>which is the ordering which greedily picks the smallest vertex required to satisfy the sorting property. it is easy to see what this means when you arrange the graph as an adjacency list:</p>\n<pre><code>2 -> []\n3 -> [8 10]\n5 -> [11]\n7 -> [8 11]\n8 -> [9]\n9 -> []\n10 -> []\n11 -> [2 9 10]\n</code></pre>\n<p>you can easily verify that in comparing to the provided ordering, each left value occurs in the ordering at a lower index than each of the right values.</p>\n<p>using this interpretation, we can implement a test case to program against:</p>\n<pre><code class=\"language-java\">public class TopologicalSortShould {\n\n  TopologicalSort topologicalSort =\n    new TopologicalSort();\n\n  @Test\n  void createCorrectTopologicalSort() {\n\n    Map&#x3C;Integer, List&#x3C;Integer>> graph =\n      Map.of(\n        2, List.of(),\n        3, List.of(8, 10),\n        5, List.of(11),\n        7, List.of(8, 11),\n        8, List.of(9),\n        9, List.of()\n        10, List.of()\n        11, List.of(2, 9, 10));\n\n    var actual =\n      topologicalSort.topologicalSort(graph);\n\n    for (var entry : graph.entrySet())\n      for (var v : entry.getValue())\n        assertThat(\n          actual.indexOf(entry.getKey()),\n          is(lessThan(actual.indexOf(v))));\n\n  }\n\n}\n</code></pre>\n<h1>the how</h1>\n<p>the best way to think about this is to interpret the graph as a group of tasks and the net of dependencies between. then the question becomes,</p>\n<p><em>for a given task, what are the tasks which need to be done before it?</em></p>\n<p>the not-so-obvious answer is the use of <em>depth first search.</em> dfs' applicability is in that its <strong>post-order traversal</strong> greedily finds all the nodes which have no outgoing edges, then backtracks to find all of the nodes which pointed to those, and then once again to find all the nodes which pointed to those, until finally arriving at the dfs starting node. </p>\n<p>we can interpret these nodes which have no outgoing edges as the tasks which need to be done first, the nodes which point to those as the tasks that need to be done second, the ones which point to those are done third, and so on back to the starting task. do this process for every node whilst only visiting each node once and you have found an ordering which shows the least dependent tasks first. reverse this and you have found an ordering which satifies the topological sort property.</p>\n<h1>recursive impl</h1>\n<p>dfs has a timeless recursive implementation; and it is the easiest form of dfs to understand. the intuition goes like so, <code>for each vertex, visit a vertex by marking it and then visit all of the vertices adjacent to it until all vertices are visited</code>. <a href=\"https://www.cs.usfca.edu/~galles/visualization/DFS.html\">this site</a> contains a wonderful visualization for gaining intuition for both directed and undirected graphs, as well as adjacency list and matrix reprisentations; an invaluable resource for the budget programmer.</p>\n<p>here is a java impl:</p>\n<pre><code class=\"language-java\">public List&#x3C;Integer> topologicalSort(\n  Map&#x3C;Integer, List&#x3C;Integer>> graph\n) {\n  var list = dfs(graph);\n  Collections.reverse(list);\n  return list;\n}\n\nprivate List&#x3C;Integer> dfs(\n  Map&#x3C;Integer, List&#x3C;Integer>> graph\n) {\n  var parent = new HashMap&#x3C;Integer, Integer>();\n  var order = new ArrayList&#x3C;Integer>();\n\n  // graph isn't necessarily connected\n  for (var entry : graph.entrySet()) {\n    var current = entry.getKey();\n    if (!parent.containsKey(current)) {\n      parent.put(current, null);\n      dfsVisit(graph, current, parent, order);\n    }\n  }\n\n  return order;\n}\n\nprivate void dfsVisit(\n  Map&#x3C;Integer, List&#x3C;Integer>> graph,\n  Integer current,\n  Map&#x3C;Integer, Integer> parent,\n  List&#x3C;Integer> order\n) {\n  var adj = graph.get(current);\n  for (var destination : adj) {\n    if (!parent.containsKey(destination)) {\n      parent.put(destination, current);\n      dfsVisit(graph, destination, parent, order);\n    }\n  }\n  // record dfs post order\n  order.add(current);\n}\n</code></pre>\n<h1>tsort</h1>\n<p>funny enough, this process is also encoded into the unix command <code>tsort</code>. running the following command will also give us a valid topological sort of a graph, given its adjacency list:</p>\n<pre><code class=\"language-bash\">tsort &#x3C;&#x3C;EOF | tr '\\n' ' ' &#x26;&#x26; echo\n3 8\n3 10\n5 11\n7 8\n7 11\n8 9\n11 2\n11 9\n11 10\nEOF\n3 5 7 11 8 10 2 9\n</code></pre>\n<p>this is good to know to check our result and to increase our unix knowledge, you never know when this will come in handy.</p>\n<p>-jared</p>\n","title":"topological sort of a directed acyclic graph","date":"2021-02-07"}},"__N_SSG":true}