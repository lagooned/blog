{"pageProps":{"postData":{"id":"array-manipulation-hackerrank","contentHtml":"<p>hey y'all. as part of my attempt to stay up-to-date on programming, as well as increase my confidence for interviews, i've been doing the hackerrank <a href=\"https://www.hackerrank.com/interview/interview-preparation-kit\">interview prep kit</a> series. one problem in particular caught my eye, and after solving it sub-optimally, i sought the best solution and learned some cool things along the way and connected it to my functional programming knowledge.</p>\n<h1>the problem</h1>\n<p><a href=\"https://www.hackerrank.com/challenges/crush/problem\">array manipulation</a>'s problem statement is as such:</p>\n<ol>\n<li>take a zeroed integer array of size n</li>\n<li>process a list of queries which transform the array</li>\n<li>then find the maximum value within the array</li>\n</ol>\n<p>the list of queries are of the form:</p>\n<pre><code>a0 b0 k0\na1 b1 k1\na2 b2 k2\n...\n</code></pre>\n<p>where a is the start index, b is the end index, and k is the number to add to the range of integers in the zerod array.</p>\n<h1>the naive solution</h1>\n<p>when i initially approached this problem, it seemed easy enough; i implemented the solution and passed the initial test cases.</p>\n<pre><code class=\"language-java\">static long arrayManipulation(int n, int[][] q) {\n    long[] arr = new long[n];\n    long max = -1;\n    for (int i = 0; i &#x3C; q.length; i++) {\n        for (int j = q[i][0]; j &#x3C; q[i][1]; j++) {\n            long val = js[j] + q[j][2];\n            if (val > max) max = val;\n            js[j] = val;\n        }\n    }\n    return max;\n}\n</code></pre>\n<p>now, come on... this isn't a terrible solution, it's actually pretty elegant; i'm even calculating the maximum value whilst performing the array manipulation. this implementation has a big problem, however. it falls over when the size of the array and queries gets huge, as the nested for loop makes the worst-case complexity <strong>O( n * m )</strong> where <strong>n</strong> is the number of queries, and <strong>m</strong> is the maximum value of <strong>b<sub>n</sub> - a<sub>n</sub></strong>.</p>\n<h1>the optimal solution</h1>\n<p>in order to fully appreciate the optimal solution, there is a very cool concept at the core of functional programming that is at the core of this solution: <strong>fold</strong>.</p>\n<h2>the fold</h2>\n<p>a fold is not some crazy dance move, it's a <em>function</em>. the whole idea of functional programming is that highly complex operations can be broken down into compositions of simple, named transformations. this concept is similar the purpose of object oriented design patterns; it gives programmers a <strong>vocabulary</strong>, which is the most important part of computer science as it lets you discuss solutions.</p>\n<p>a fold is result of the following expression when built from a list, when done with the addition operator:</p>\n<pre><code>foldl (+) 0 [1,2,3,4,5] => (((((0+1)+2)+3)+4)+5) => 15\nfoldr (+) 0 [1,2,3,4,5] => (1+(2+(3+(4+(5+0))))) => 15\n</code></pre>\n<p>when the operator you use is communative, this has the effect of replacing the commas in a list definition with the operator. this is a more specific version of a <strong>reduce</strong> which is found in most langauges. here is an example of using both a left and right fold with a list of strings and the concatination operation:</p>\n<pre><code>foldl (++) \"\" [\"1\",\"2\",\"3\",\"4\",\"5\"] => \"54321\"\nfoldr (++) \"\" [\"1\",\"2\",\"3\",\"4\",\"5\"] => \"12345\"\n</code></pre>\n<p>as you can see using this can be very useful for concicely reducing a list to a single value in a particular order</p>\n<p>here are the definitions in haskell:</p>\n<pre><code class=\"language-haskell\">foldl f z [] = z\nfoldl f z (x:xs) = foldl f (f z x) xs\n\nfoldr f z [] = z\nfoldr f z (x:xs) = f x (foldr f z xs)\n</code></pre>\n<h2>from fold to scan</h2>\n<p>the reason i've introduced the fold is because it is a good segue into its sister function, the <strong>scan</strong>. a scan is similar to a fold, but instead of reducing the list to a single value, it reduces it into a list of the successive values created by doing the folding operation:</p>\n<pre><code>scanl (+) 0 [1,2,3] => [0+1,((0+1)+2),(((0+1)+2)+3)] => [1,3,6]\nscanl (+) 0 [1,2,3] => [0+1,(0+(1+2)),(0+(1+(2+3)))] => [1,3,6]\n</code></pre>\n<p>this function may look quite innoquous, but it is in fact the key to optimizing the array manipulation problem.</p>\n<p>here's its haskell definition for completeness:</p>\n<pre><code class=\"language-haskell\">scanl :: (b -> a -> b) -> b -> [a] -> [b]\nscanl = scanlGo\n  where\n    scanlGo :: (b -> a -> b) -> b -> [a] -> [b]\n    scanlGo f q ls = q : (case ls of\n                          [] -> []\n                          x:xs -> scanlGo f (f q x) xs)\n\nscanr :: (a -> b -> b) -> b -> [a] -> [b]\nscanr _ q0 [] = [q0]\nscanr f q0 (x:xs) = f x q : qs\n                    where qs@(q:_) = scanr f q0 xs\n</code></pre>\n<p>you don't really have to understand these, it's just helpful to explore how they are implemented. i found the implementations <a href=\"https://hackage.haskell.org/package/base-4.14.1.0/docs/src/GHC.List.html\">here</a>.</p>\n<h1>the array manipulation</h1>\n<p>the complexity of the array manipulation step of the original problem can be reduced by utilizing the scan via the following observation:</p>\n<pre><code>scanl (+) 0 [0,0,1,0,0,0,0,-1,0,0] => [0,0,1,1,1,1,1,1,0,0]\nscanr (+) 0 [0,0,-1,0,0,0,0,1,0,0] => [0,0,1,1,1,1,1,1,0,0]\n</code></pre>\n<p>this is huge<sup>tm</sup>, as it shows that we can use this scan operation to remove the inner for loop from the naive solution. this is the final implementation in java:</p>\n<pre><code class=\"language-java\">static long arrayManipulation(int n, int[][] queries) {\n    long[] ns = new long[n+2];\n    for (int i = 0; i &#x3C; queries.length; i++) {\n        int a = queries[i][0];\n        int b = queries[i][1];\n        int k = queries[i][2];\n        ns[a-1] = ns[a-1]+k;\n        ns[b] = ns[b]-k;\n    }\n    long max = -1l;\n    for (int i = 0; i &#x3C; n; i++) {\n        ns[i+1] = ns[i]+ns[i+1];\n        if (ns[i] > max) max = ns[i];\n    }\n    return max;\n}\n</code></pre>\n<p>also, to fit with our functional programming knowledge, here is an implementation in scala:</p>\n<pre><code class=\"language-scala\">object ArrayManipulation extends App {\n\n  val n = 10\n\n  val queries = List(\n    (1,10,1),\n    (2,9,1),\n    (3,8,1),\n    (4,7,1),\n    (5,6,1)\n  )\n\n  println(\n    queries\n      .map(query => (-1 + query._1, -1 + query._2, query._3))\n      .map(adjusted => List.tabulate(n) { i =>\n        i match {\n          case adjusted._1 => adjusted._3\n          case adjusted._2 => -(adjusted._3)\n          case _ => 0\n        }\n      })\n      .fold(List.tabulate(n)(i => 0)) { (current, accumulator) =>\n        current.zip(accumulator).map(zipped => zipped._1 + zipped._2)\n      }\n      .scan(0)(_ + _)\n      .max)\n\n}\n</code></pre>\n<p>give this one a try in your favorite language :)</p>\n<p>-jared</p>\n","title":"interview prep: array manipulation","date":"2021-01-13"}},"__N_SSG":true}