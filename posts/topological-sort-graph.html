<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="description" content="a blog by a guy who likes emacs"/><meta property="og:image" content="/blog/images/jared-engler-blog.png"/><meta name="og:title" content="jared.engler.blog"/><meta name="twitter:card" content="summary_large_image"/><title>topological sort of a directed acyclic graph</title><meta name="next-head-count" content="7"/><link rel="preload" href="/blog/_next/static/css/dfd64abbb58af9f5d7f8.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/dfd64abbb58af9f5d7f8.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/9eb0ab91ec5bd9812a2e.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/9eb0ab91ec5bd9812a2e.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/main-f094e29a130fd0913879.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework.492e6181467ebf2e0a6c.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons.4e446db3eadf18dc2ad0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-70651e13387bad6b3f4b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.d4a3db8613b49501ab76.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/posts/%5Bid%5D-248d96d842634965509c.js" as="script"/></head><body><div id="__next"><div class="layout_container__2t4v2"><header class="layout_header__2rhWq"><a href="/blog"><img src="/blog/images/me-centered-better.png" class="layout_headerImage__2h5On utils_borderCircle__13qdJ" alt="jared.engler"/></a><h2 class="utils_headingLg__de7p0"><a class="utils_colorInherit__3Gudf" href="/blog">jared.engler</a></h2></header><main><article><h1 class="utils_headingXl__1XecN">topological sort of a directed acyclic graph</h1><div class="utils_lightText__12Ckm"><time dateTime="2021-02-07">February 7, 2021</time></div><div class="utils_content__zjeg5"><p>hey yall! my interview prep journey knows no bounds, and good thing because it's infinite content. <a href="https://en.wikipedia.org/wiki/Depth-first_search"><strong>depth-first search</strong></a> (commonly shortified as <em>dfs</em>) is a wide-spread concept in computer science and offers good insight and introduction into the analysis of graphs. one particular application of depth-first search of a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph"><strong>directed acyclic graph</strong></a> (or <em>dag</em> for short) caught my interest, that being <strong>topological sort</strong>.</p>
<h1>topsort</h1>
<p>the topological sort of a dag is an ordering of all its vertex labels which satisfies the following statement:</p>
<p><code>for all vertex v in any dag, there exists an ordering in which v occurs *after* the set of vertices that v directs to</code></p>
<p>so in the following graph:</p>
<p><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="100%" height="100%" viewBox="0.00 0.00 206.00 188.00"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)"><title>G</title>
<polygon fill="#000000" stroke="transparent" points="-4,4 -4,-184 202,-184 202,4 -4,4"/>
<g id="node1" class="node"><ellipse fill="none" stroke="#FFFFFF" cx="171" cy="-162" rx="27" ry="18"/><text text-anchor="middle" x="171" y="-157.8" font-size="14.00" fill="#FFFFFF">3</text></g>
<g id="node2" class="node"><ellipse fill="none" stroke="#FFFFFF" cx="107" cy="-90" rx="27" ry="18"/><text text-anchor="middle" x="107" y="-85.8" font-size="14.00" fill="#FFFFFF">8</text></g>
<g id="edge1" class="edge"><path fill="none" stroke="#FFFFFF" d="M157.113,-146.3771C148.4747,-136.659 137.2107,-123.987 127.5503,-113.1191"/><polygon fill="#FFFFFF" stroke="#FFFFFF" points="130.1196,-110.7413 120.8599,-105.5924 124.8877,-115.3918 130.1196,-110.7413"/></g>
<g id="node3" class="node"><ellipse fill="none" stroke="#FFFFFF" cx="171" cy="-18" rx="27" ry="18"/><text text-anchor="middle" x="171" y="-13.8" font-size="14.00" fill="#FFFFFF">10</text></g>
<g id="edge2" class="edge"><path fill="none" stroke="#FFFFFF" d="M171,-143.7623C171,-119.201 171,-75.2474 171,-46.3541"/><polygon fill="#FFFFFF" stroke="#FFFFFF" points="174.5001,-46.0896 171,-36.0896 167.5001,-46.0897 174.5001,-46.0896"/></g>
<g id="node7" class="node"><ellipse fill="none" stroke="#FFFFFF" cx="99" cy="-18" rx="27" ry="18"/><text text-anchor="middle" x="99" y="-13.8" font-size="14.00" fill="#FFFFFF">9</text></g>
<g id="edge6" class="edge"><path fill="none" stroke="#FFFFFF" d="M104.9813,-71.8314C104.1257,-64.131 103.1083,-54.9743 102.1574,-46.4166"/><polygon fill="#FFFFFF" stroke="#FFFFFF" points="105.6289,-45.9656 101.0459,-36.4133 98.6717,-46.7386 105.6289,-45.9656"/></g>
<g id="node4" class="node"><ellipse fill="none" stroke="#FFFFFF" cx="27" cy="-162" rx="27" ry="18"/><text text-anchor="middle" x="27" y="-157.8" font-size="14.00" fill="#FFFFFF">5</text></g>
<g id="node5" class="node"><ellipse fill="none" stroke="#FFFFFF" cx="35" cy="-90" rx="27" ry="18"/><text text-anchor="middle" x="35" y="-85.8" font-size="14.00" fill="#FFFFFF">11</text></g>
<g id="edge3" class="edge"><path fill="none" stroke="#FFFFFF" d="M29.0187,-143.8314C29.8743,-136.131 30.8917,-126.9743 31.8426,-118.4166"/><polygon fill="#FFFFFF" stroke="#FFFFFF" points="35.3283,-118.7386 32.9541,-108.4133 28.3711,-117.9656 35.3283,-118.7386"/></g>
<g id="edge9" class="edge"><path fill="none" stroke="#FFFFFF" d="M56.25,-78.75C78.8722,-66.7735 114.8739,-47.7138 140.516,-34.1386"/><polygon fill="#FFFFFF" stroke="#FFFFFF" points="142.2501,-37.1808 149.4504,-29.4086 138.9749,-30.9943 142.2501,-37.1808"/></g>
<g id="edge8" class="edge"><path fill="none" stroke="#FFFFFF" d="M48.887,-74.3771C57.5253,-64.659 68.7893,-51.987 78.4497,-41.1191"/><polygon fill="#FFFFFF" stroke="#FFFFFF" points="81.1123,-43.3918 85.1401,-33.5924 75.8804,-38.7413 81.1123,-43.3918"/></g>
<g id="node8" class="node"><ellipse fill="none" stroke="#FFFFFF" cx="27" cy="-18" rx="27" ry="18"/><text text-anchor="middle" x="27" y="-13.8" font-size="14.00" fill="#FFFFFF">2</text></g>
<g id="edge7" class="edge"><path fill="none" stroke="#FFFFFF" d="M32.9813,-71.8314C32.1257,-64.131 31.1083,-54.9743 30.1574,-46.4166"/><polygon fill="#FFFFFF" stroke="#FFFFFF" points="33.6289,-45.9656 29.0459,-36.4133 26.6717,-46.7386 33.6289,-45.9656"/></g>
<g id="node6" class="node"><ellipse fill="none" stroke="#FFFFFF" cx="99" cy="-162" rx="27" ry="18"/><text text-anchor="middle" x="99" y="-157.8" font-size="14.00" fill="#FFFFFF">7</text></g>
<g id="edge4" class="edge"><path fill="none" stroke="#FFFFFF" d="M101.0187,-143.8314C101.8743,-136.131 102.8917,-126.9743 103.8426,-118.4166"/><polygon fill="#FFFFFF" stroke="#FFFFFF" points="107.3283,-118.7386 104.9541,-108.4133 100.3711,-117.9656 107.3283,-118.7386"/></g>
<g id="edge5" class="edge"><path fill="none" stroke="#FFFFFF" d="M85.113,-146.3771C76.4747,-136.659 65.2107,-123.987 55.5503,-113.1191"/><polygon fill="#FFFFFF" stroke="#FFFFFF" points="58.1196,-110.7413 48.8599,-105.5924 52.8877,-115.3918 58.1196,-110.7413"/></g></p>
<p>there exist multiple orderings which satisfy a topological sort, one such being:</p>
<p><code>[3, 5, 7, 8, 11, 2, 9, 10]</code></p>
<p>which is the ordering which greedily picks the smallest vertex required to satisfy the sorting property. it is easy to see what this means when you arrange the graph as an adjacency list:</p>
<pre><code>2 -> []
3 -> [8 10]
5 -> [11]
7 -> [8 11]
8 -> [9]
9 -> []
10 -> []
11 -> [2 9 10]
</code></pre>
<p>you can easily verify that in comparing to the provided ordering, each left value occurs in the ordering at a lower index than each of the right values.</p>
<p>using this interpretation, we can implement a test case to program against:</p>
<pre><code class="language-java">public class TopologicalSortShould {

  TopologicalSort topologicalSort =
    new TopologicalSort();

  @Test
  void createCorrectTopologicalSort() {

    Map&#x3C;Integer, List&#x3C;Integer>> graph =
      Map.of(
        2, List.of(),
        3, List.of(8, 10),
        5, List.of(11),
        7, List.of(8, 11),
        8, List.of(9),
        9, List.of()
        10, List.of()
        11, List.of(2, 9, 10));

    var actual =
      topologicalSort.topologicalSort(graph);

    for (var entry : graph.entrySet())
      for (var v : entry.getValue())
        assertThat(
          actual.indexOf(entry.getKey()),
          is(lessThan(actual.indexOf(v))));

  }

}
</code></pre>
<h1>the how</h1>
<p>the best way to think about this is to interpret the graph as a group of tasks and the net of dependencies between. then the question becomes,</p>
<p><em>for a given task, what are the tasks which need to be done before it?</em></p>
<p>the not-so-obvious answer is the use of <em>depth first search.</em> dfs' applicability is in that its <strong>post-order traversal</strong> greedily finds all the nodes which have no outgoing edges, then backtracks to find all of the nodes which pointed to those, and then once again to find all the nodes which pointed to those, until finally arriving at the dfs starting node. </p>
<p>we can interpret these nodes which have no outgoing edges as the tasks which need to be done first, the nodes which point to those as the tasks that need to be done second, the ones which point to those are done third, and so on back to the starting task. do this process for every node whilst only visiting each node once and you have found an ordering which shows the least dependent tasks first. reverse this and you have found an ordering which satifies the topological sort property.</p>
<h1>recursive impl</h1>
<p>dfs has a timeless recursive implementation; and it is the easiest form of dfs to understand. the intuition goes like so, <code>for each vertex, visit a vertex by marking it and then visit all of the vertices adjacent to it until all vertices are visited</code>. <a href="https://www.cs.usfca.edu/~galles/visualization/DFS.html">this site</a> contains a wonderful visualization for gaining intuition for both directed and undirected graphs, as well as adjacency list and matrix reprisentations; an invaluable resource for the budget programmer.</p>
<p>here is a java impl:</p>
<pre><code class="language-java">public List&#x3C;Integer> topologicalSort(
  Map&#x3C;Integer, List&#x3C;Integer>> graph
) {
  var list = dfs(graph);
  Collections.reverse(list);
  return list;
}

private List&#x3C;Integer> dfs(
  Map&#x3C;Integer, List&#x3C;Integer>> graph
) {
  var parent = new HashMap&#x3C;Integer, Integer>();
  var order = new ArrayList&#x3C;Integer>();

  // graph isn't necessarily connected
  for (var entry : graph.entrySet()) {
    var current = entry.getKey();
    if (!parent.containsKey(current)) {
      parent.put(current, null);
      dfsVisit(graph, current, parent, order);
    }
  }

  return order;
}

private void dfsVisit(
  Map&#x3C;Integer, List&#x3C;Integer>> graph,
  Integer current,
  Map&#x3C;Integer, Integer> parent,
  List&#x3C;Integer> order
) {
  var adj = graph.get(current);
  for (var destination : adj) {
    if (!parent.containsKey(destination)) {
      parent.put(destination, current);
      dfsVisit(graph, destination, parent, order);
    }
  }
  // record dfs post order
  order.add(current);
}
</code></pre>
<h1>tsort</h1>
<p>funny enough, this process is also encoded into the unix command <code>tsort</code>. running the following command will also give us a valid topological sort of a graph, given its adjacency list:</p>
<pre><code class="language-bash">tsort &#x3C;&#x3C;EOF | tr '\n' ' ' &#x26;&#x26; echo
3 8
3 10
5 11
7 8
7 11
8 9
11 2
11 9
11 10
EOF
3 5 7 11 8 10 2 9
</code></pre>
<p>this is good to know to check our result and to increase our unix knowledge, you never know when this will come in handy.</p>
<p>-jared</p>
</div></article></main><div class="layout_backToHome__1vZsp"><a href="/blog">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"topological-sort-graph","contentHtml":"\u003cp\u003ehey yall! my interview prep journey knows no bounds, and good thing because it's infinite content. \u003ca href=\"https://en.wikipedia.org/wiki/Depth-first_search\"\u003e\u003cstrong\u003edepth-first search\u003c/strong\u003e\u003c/a\u003e (commonly shortified as \u003cem\u003edfs\u003c/em\u003e) is a wide-spread concept in computer science and offers good insight and introduction into the analysis of graphs. one particular application of depth-first search of a \u003ca href=\"https://en.wikipedia.org/wiki/Directed_acyclic_graph\"\u003e\u003cstrong\u003edirected acyclic graph\u003c/strong\u003e\u003c/a\u003e (or \u003cem\u003edag\u003c/em\u003e for short) caught my interest, that being \u003cstrong\u003etopological sort\u003c/strong\u003e.\u003c/p\u003e\n\u003ch1\u003etopsort\u003c/h1\u003e\n\u003cp\u003ethe topological sort of a dag is an ordering of all its vertex labels which satisfies the following statement:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efor all vertex v in any dag, there exists an ordering in which v occurs *after* the set of vertices that v directs to\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eso in the following graph:\u003c/p\u003e\n\u003cp\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100%\" height=\"100%\" viewBox=\"0.00 0.00 206.00 188.00\"\u003e\u003cg id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 184)\"\u003e\u003ctitle\u003eG\u003c/title\u003e\n\u003cpolygon fill=\"#000000\" stroke=\"transparent\" points=\"-4,4 -4,-184 202,-184 202,4 -4,4\"/\u003e\n\u003cg id=\"node1\" class=\"node\"\u003e\u003cellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"171\" cy=\"-162\" rx=\"27\" ry=\"18\"/\u003e\u003ctext text-anchor=\"middle\" x=\"171\" y=\"-157.8\" font-size=\"14.00\" fill=\"#FFFFFF\"\u003e3\u003c/text\u003e\u003c/g\u003e\n\u003cg id=\"node2\" class=\"node\"\u003e\u003cellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"107\" cy=\"-90\" rx=\"27\" ry=\"18\"/\u003e\u003ctext text-anchor=\"middle\" x=\"107\" y=\"-85.8\" font-size=\"14.00\" fill=\"#FFFFFF\"\u003e8\u003c/text\u003e\u003c/g\u003e\n\u003cg id=\"edge1\" class=\"edge\"\u003e\u003cpath fill=\"none\" stroke=\"#FFFFFF\" d=\"M157.113,-146.3771C148.4747,-136.659 137.2107,-123.987 127.5503,-113.1191\"/\u003e\u003cpolygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"130.1196,-110.7413 120.8599,-105.5924 124.8877,-115.3918 130.1196,-110.7413\"/\u003e\u003c/g\u003e\n\u003cg id=\"node3\" class=\"node\"\u003e\u003cellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"171\" cy=\"-18\" rx=\"27\" ry=\"18\"/\u003e\u003ctext text-anchor=\"middle\" x=\"171\" y=\"-13.8\" font-size=\"14.00\" fill=\"#FFFFFF\"\u003e10\u003c/text\u003e\u003c/g\u003e\n\u003cg id=\"edge2\" class=\"edge\"\u003e\u003cpath fill=\"none\" stroke=\"#FFFFFF\" d=\"M171,-143.7623C171,-119.201 171,-75.2474 171,-46.3541\"/\u003e\u003cpolygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"174.5001,-46.0896 171,-36.0896 167.5001,-46.0897 174.5001,-46.0896\"/\u003e\u003c/g\u003e\n\u003cg id=\"node7\" class=\"node\"\u003e\u003cellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"99\" cy=\"-18\" rx=\"27\" ry=\"18\"/\u003e\u003ctext text-anchor=\"middle\" x=\"99\" y=\"-13.8\" font-size=\"14.00\" fill=\"#FFFFFF\"\u003e9\u003c/text\u003e\u003c/g\u003e\n\u003cg id=\"edge6\" class=\"edge\"\u003e\u003cpath fill=\"none\" stroke=\"#FFFFFF\" d=\"M104.9813,-71.8314C104.1257,-64.131 103.1083,-54.9743 102.1574,-46.4166\"/\u003e\u003cpolygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"105.6289,-45.9656 101.0459,-36.4133 98.6717,-46.7386 105.6289,-45.9656\"/\u003e\u003c/g\u003e\n\u003cg id=\"node4\" class=\"node\"\u003e\u003cellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"27\" cy=\"-162\" rx=\"27\" ry=\"18\"/\u003e\u003ctext text-anchor=\"middle\" x=\"27\" y=\"-157.8\" font-size=\"14.00\" fill=\"#FFFFFF\"\u003e5\u003c/text\u003e\u003c/g\u003e\n\u003cg id=\"node5\" class=\"node\"\u003e\u003cellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"35\" cy=\"-90\" rx=\"27\" ry=\"18\"/\u003e\u003ctext text-anchor=\"middle\" x=\"35\" y=\"-85.8\" font-size=\"14.00\" fill=\"#FFFFFF\"\u003e11\u003c/text\u003e\u003c/g\u003e\n\u003cg id=\"edge3\" class=\"edge\"\u003e\u003cpath fill=\"none\" stroke=\"#FFFFFF\" d=\"M29.0187,-143.8314C29.8743,-136.131 30.8917,-126.9743 31.8426,-118.4166\"/\u003e\u003cpolygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"35.3283,-118.7386 32.9541,-108.4133 28.3711,-117.9656 35.3283,-118.7386\"/\u003e\u003c/g\u003e\n\u003cg id=\"edge9\" class=\"edge\"\u003e\u003cpath fill=\"none\" stroke=\"#FFFFFF\" d=\"M56.25,-78.75C78.8722,-66.7735 114.8739,-47.7138 140.516,-34.1386\"/\u003e\u003cpolygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"142.2501,-37.1808 149.4504,-29.4086 138.9749,-30.9943 142.2501,-37.1808\"/\u003e\u003c/g\u003e\n\u003cg id=\"edge8\" class=\"edge\"\u003e\u003cpath fill=\"none\" stroke=\"#FFFFFF\" d=\"M48.887,-74.3771C57.5253,-64.659 68.7893,-51.987 78.4497,-41.1191\"/\u003e\u003cpolygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"81.1123,-43.3918 85.1401,-33.5924 75.8804,-38.7413 81.1123,-43.3918\"/\u003e\u003c/g\u003e\n\u003cg id=\"node8\" class=\"node\"\u003e\u003cellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"27\" cy=\"-18\" rx=\"27\" ry=\"18\"/\u003e\u003ctext text-anchor=\"middle\" x=\"27\" y=\"-13.8\" font-size=\"14.00\" fill=\"#FFFFFF\"\u003e2\u003c/text\u003e\u003c/g\u003e\n\u003cg id=\"edge7\" class=\"edge\"\u003e\u003cpath fill=\"none\" stroke=\"#FFFFFF\" d=\"M32.9813,-71.8314C32.1257,-64.131 31.1083,-54.9743 30.1574,-46.4166\"/\u003e\u003cpolygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"33.6289,-45.9656 29.0459,-36.4133 26.6717,-46.7386 33.6289,-45.9656\"/\u003e\u003c/g\u003e\n\u003cg id=\"node6\" class=\"node\"\u003e\u003cellipse fill=\"none\" stroke=\"#FFFFFF\" cx=\"99\" cy=\"-162\" rx=\"27\" ry=\"18\"/\u003e\u003ctext text-anchor=\"middle\" x=\"99\" y=\"-157.8\" font-size=\"14.00\" fill=\"#FFFFFF\"\u003e7\u003c/text\u003e\u003c/g\u003e\n\u003cg id=\"edge4\" class=\"edge\"\u003e\u003cpath fill=\"none\" stroke=\"#FFFFFF\" d=\"M101.0187,-143.8314C101.8743,-136.131 102.8917,-126.9743 103.8426,-118.4166\"/\u003e\u003cpolygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"107.3283,-118.7386 104.9541,-108.4133 100.3711,-117.9656 107.3283,-118.7386\"/\u003e\u003c/g\u003e\n\u003cg id=\"edge5\" class=\"edge\"\u003e\u003cpath fill=\"none\" stroke=\"#FFFFFF\" d=\"M85.113,-146.3771C76.4747,-136.659 65.2107,-123.987 55.5503,-113.1191\"/\u003e\u003cpolygon fill=\"#FFFFFF\" stroke=\"#FFFFFF\" points=\"58.1196,-110.7413 48.8599,-105.5924 52.8877,-115.3918 58.1196,-110.7413\"/\u003e\u003c/g\u003e\u003c/p\u003e\n\u003cp\u003ethere exist multiple orderings which satisfy a topological sort, one such being:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e[3, 5, 7, 8, 11, 2, 9, 10]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003ewhich is the ordering which greedily picks the smallest vertex required to satisfy the sorting property. it is easy to see what this means when you arrange the graph as an adjacency list:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e2 -\u003e []\n3 -\u003e [8 10]\n5 -\u003e [11]\n7 -\u003e [8 11]\n8 -\u003e [9]\n9 -\u003e []\n10 -\u003e []\n11 -\u003e [2 9 10]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eyou can easily verify that in comparing to the provided ordering, each left value occurs in the ordering at a lower index than each of the right values.\u003c/p\u003e\n\u003cp\u003eusing this interpretation, we can implement a test case to program against:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class TopologicalSortShould {\n\n  TopologicalSort topologicalSort =\n    new TopologicalSort();\n\n  @Test\n  void createCorrectTopologicalSort() {\n\n    Map\u0026#x3C;Integer, List\u0026#x3C;Integer\u003e\u003e graph =\n      Map.of(\n        2, List.of(),\n        3, List.of(8, 10),\n        5, List.of(11),\n        7, List.of(8, 11),\n        8, List.of(9),\n        9, List.of()\n        10, List.of()\n        11, List.of(2, 9, 10));\n\n    var actual =\n      topologicalSort.topologicalSort(graph);\n\n    for (var entry : graph.entrySet())\n      for (var v : entry.getValue())\n        assertThat(\n          actual.indexOf(entry.getKey()),\n          is(lessThan(actual.indexOf(v))));\n\n  }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003ethe how\u003c/h1\u003e\n\u003cp\u003ethe best way to think about this is to interpret the graph as a group of tasks and the net of dependencies between. then the question becomes,\u003c/p\u003e\n\u003cp\u003e\u003cem\u003efor a given task, what are the tasks which need to be done before it?\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003ethe not-so-obvious answer is the use of \u003cem\u003edepth first search.\u003c/em\u003e dfs' applicability is in that its \u003cstrong\u003epost-order traversal\u003c/strong\u003e greedily finds all the nodes which have no outgoing edges, then backtracks to find all of the nodes which pointed to those, and then once again to find all the nodes which pointed to those, until finally arriving at the dfs starting node. \u003c/p\u003e\n\u003cp\u003ewe can interpret these nodes which have no outgoing edges as the tasks which need to be done first, the nodes which point to those as the tasks that need to be done second, the ones which point to those are done third, and so on back to the starting task. do this process for every node whilst only visiting each node once and you have found an ordering which shows the least dependent tasks first. reverse this and you have found an ordering which satifies the topological sort property.\u003c/p\u003e\n\u003ch1\u003erecursive impl\u003c/h1\u003e\n\u003cp\u003edfs has a timeless recursive implementation; and it is the easiest form of dfs to understand. the intuition goes like so, \u003ccode\u003efor each vertex, visit a vertex by marking it and then visit all of the vertices adjacent to it until all vertices are visited\u003c/code\u003e. \u003ca href=\"https://www.cs.usfca.edu/~galles/visualization/DFS.html\"\u003ethis site\u003c/a\u003e contains a wonderful visualization for gaining intuition for both directed and undirected graphs, as well as adjacency list and matrix reprisentations; an invaluable resource for the budget programmer.\u003c/p\u003e\n\u003cp\u003ehere is a java impl:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic List\u0026#x3C;Integer\u003e topologicalSort(\n  Map\u0026#x3C;Integer, List\u0026#x3C;Integer\u003e\u003e graph\n) {\n  var list = dfs(graph);\n  Collections.reverse(list);\n  return list;\n}\n\nprivate List\u0026#x3C;Integer\u003e dfs(\n  Map\u0026#x3C;Integer, List\u0026#x3C;Integer\u003e\u003e graph\n) {\n  var parent = new HashMap\u0026#x3C;Integer, Integer\u003e();\n  var order = new ArrayList\u0026#x3C;Integer\u003e();\n\n  // graph isn't necessarily connected\n  for (var entry : graph.entrySet()) {\n    var current = entry.getKey();\n    if (!parent.containsKey(current)) {\n      parent.put(current, null);\n      dfsVisit(graph, current, parent, order);\n    }\n  }\n\n  return order;\n}\n\nprivate void dfsVisit(\n  Map\u0026#x3C;Integer, List\u0026#x3C;Integer\u003e\u003e graph,\n  Integer current,\n  Map\u0026#x3C;Integer, Integer\u003e parent,\n  List\u0026#x3C;Integer\u003e order\n) {\n  var adj = graph.get(current);\n  for (var destination : adj) {\n    if (!parent.containsKey(destination)) {\n      parent.put(destination, current);\n      dfsVisit(graph, destination, parent, order);\n    }\n  }\n  // record dfs post order\n  order.add(current);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003etsort\u003c/h1\u003e\n\u003cp\u003efunny enough, this process is also encoded into the unix command \u003ccode\u003etsort\u003c/code\u003e. running the following command will also give us a valid topological sort of a graph, given its adjacency list:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003etsort \u0026#x3C;\u0026#x3C;EOF | tr '\\n' ' ' \u0026#x26;\u0026#x26; echo\n3 8\n3 10\n5 11\n7 8\n7 11\n8 9\n11 2\n11 9\n11 10\nEOF\n3 5 7 11 8 10 2 9\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethis is good to know to check our result and to increase our unix knowledge, you never know when this will come in handy.\u003c/p\u003e\n\u003cp\u003e-jared\u003c/p\u003e\n","title":"topological sort of a directed acyclic graph","date":"2021-02-07"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"topological-sort-graph"},"buildId":"rYb3Nc1C-BSbDG5d2vI0B","assetPrefix":"/blog","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-86038f8325ecf14c2308.js"></script><script src="/blog/_next/static/chunks/main-f094e29a130fd0913879.js" async=""></script><script src="/blog/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/blog/_next/static/chunks/framework.492e6181467ebf2e0a6c.js" async=""></script><script src="/blog/_next/static/chunks/commons.4e446db3eadf18dc2ad0.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-70651e13387bad6b3f4b.js" async=""></script><script src="/blog/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.d4a3db8613b49501ab76.js" async=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bid%5D-248d96d842634965509c.js" async=""></script><script src="/blog/_next/static/rYb3Nc1C-BSbDG5d2vI0B/_buildManifest.js" async=""></script><script src="/blog/_next/static/rYb3Nc1C-BSbDG5d2vI0B/_ssgManifest.js" async=""></script></body></html>