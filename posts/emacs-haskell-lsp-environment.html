<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="description" content="a blog by a guy who likes emacs"/><meta property="og:image" content="/blog/images/jared-engler-blog.png"/><meta name="og:title" content="jared.engler.blog"/><meta name="twitter:card" content="summary_large_image"/><title>make haskell less intimidating with emacs &amp; lsp</title><meta name="next-head-count" content="7"/><link rel="preload" href="/blog/_next/static/css/dfd64abbb58af9f5d7f8.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/dfd64abbb58af9f5d7f8.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/9eb0ab91ec5bd9812a2e.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/9eb0ab91ec5bd9812a2e.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/main-f094e29a130fd0913879.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework.492e6181467ebf2e0a6c.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons.4e446db3eadf18dc2ad0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-70651e13387bad6b3f4b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.596cc5897b16dd510190.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/posts/%5Bid%5D-248d96d842634965509c.js" as="script"/></head><body><div id="__next"><div class="layout_container__2t4v2"><header class="layout_header__2rhWq"><a href="/blog"><img src="/blog/images/me-centered-better.png" class="layout_headerImage__2h5On utils_borderCircle__13qdJ" alt="jared.engler"/></a><h2 class="utils_headingLg__de7p0"><a class="utils_colorInherit__3Gudf" href="/blog">jared.engler</a></h2></header><main><article><h1 class="utils_headingXl__1XecN">make haskell less intimidating with emacs &amp; lsp</h1><div class="utils_lightText__12Ckm"><time dateTime="2021-03-02">March 2, 2021</time></div><div class="utils_content__zjeg5"><p>as i said before, there would be many posts about emacs and this is no exception. in this iteration, we are looking at haskell language server protocol integration. as i am currently, and always will be, learning haskell extremely slowly, i figured it necessary to leverage my experience with emacs, lsp, and gnu/linux to reap the benefits of the haskell community's ide integration efforts.</p>
<h1>terms</h1>
<ul>
<li>
<p><strong><a href="https://github.com/microsoft/language-server-protocol">lsp</a></strong></p>
<ul>
<li>short for <em>language server protocol</em>. this is a standard for implementing a language server for a given language. it defines how to create a rest server which understands its implementing language (whether it be haskell, java, c++, scala, or what have you) and accepts queries which return information which can aid in the development process.</li>
</ul>
</li>
<li>
<p><strong><a href="https://www.haskell.org">haskell</a></strong></p>
<ul>
<li>named after logicial haskell curry, haskell is a general-purpose, statically-typed, &#x26; purely-functional programming language which touts most of the recent innovations in programming and is a consistent source of good ideas for other languages to copy from.</li>
</ul>
</li>
<li>
<p><strong><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Modes.html">mode</a></strong></p>
<ul>
<li>an operating mode for emacs which is enabled upon opening a buffer. a mode usually offers a set of functionality that is useful for the type of buffer that was opened. for example, when opening a <em>*.hs</em> file, <strong>haskell-mode</strong> is started.</li>
</ul>
</li>
<li>
<p><strong><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Setting-Hooks.html">hook</a></strong></p>
<ul>
<li>an unordered list of elisp functions which run when a particular <em>mode</em> is enabled. for example, when <em>haskell-mode</em>, <strong>haskell-mode-hook</strong> is executed.</li>
</ul>
</li>
<li>
<p><strong><a href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a></strong></p>
<ul>
<li>a client library for emacs which interacts with servers which implement the language server protocol.</li>
</ul>
</li>
<li>
<p><strong><a href="https://github.com/jwiegley/use-package">use-package</a></strong></p>
<ul>
<li>a set of elisp functions and macros which makes it easy to lazy-load elisp packages with particular configurations. while it is completely optional, loading elisp packages all at once can be quite time complex and cause very slow start-up time. use of this is very much advised as it will future proof your configurations.</li>
</ul>
</li>
</ul>
<h1>scope</h1>
<p>as was said in my previous <a href="/blog/posts/emacs-scala-env">scala-lsp post</a>, in order to keep this short, i will only be going over the setup of <em>use-package</em>, <em>lsp-mode</em>, and the operating system configurations required to make a elegant development environment. if you would like to know more about emacs, please check out the following:</p>
<ul>
<li>
<p><strong><a href="http://github.com/lagooned/emacs">je/emacs</a></strong></p>
<ul>
<li>the configuration that i currently use. it is heavily inspired by <em><a href="https://www.spacemacs.org">spacemacs</a></em> and <em><a href="https://github.com/hlissner/doom-emacs">doom-emacs</a></em>. please feel free to copy stuff out of my config or raise a pr, id be happy to have a look at it.</li>
<li>here you can find the configuration as i implemented it, in terms of my own configuration setup, please feel free to use this as a reference</li>
</ul>
</li>
<li>
<p><strong><a href="https://sanemacs.com">sanemacs</a></strong></p>
<ul>
<li>provides a good set of sane defaults</li>
</ul>
</li>
<li>
<p><strong><a href="https://github.com/emacs-tw/awesome-emacs">awesome emacs</a></strong></p>
<ul>
<li>a great, frequently updated place to look for and learn about more packages to add to your emacs configuration.</li>
</ul>
</li>
</ul>
<h1>install binaries</h1>
<ul>
<li><a href="https://docs.haskellstack.org/en/stable/README/#the-haskell-tool-stack">stack</a>
<ul>
<li>follow the guide for this and make sure stack is in your <strong>user-wide ~/.profile $PATH</strong> (see the guide <a href="https://stackabuse.com/how-to-permanently-set-path-in-linux/#usingaprofilefiletosetyourpath">here</a> for help) so that emacs can see it</li>
</ul>
</li>
<li><a href="https://github.com/haskell/haskell-language-server">haskell-language-server</a>
<ul>
<li>either build from source or download the pre-compiled binaries; again making sure it is in your <strong>user-wide ~/.profile $PATH</strong> </li>
</ul>
</li>
</ul>
<h1>use-package: what do?</h1>
<p>i previously went over the syntax for <strong>use-package</strong> <strong><a href="/blog/posts/emacs-scala-env#using-use-package">here</a></strong>, as well as the initial <strong>package.el</strong> setup <strong><a href="/blog/posts/emacs-scala-env#setting-up-package-el">here</a></strong>. perform both of these on your local machine to continue.</p>
<h1>setting up lsp</h1>
<p>with your init.el setup to handle packages, you can now add the following in order to finish the emacs portion of the setup</p>
<pre><code class="language-elisp">(use-package company
  :ensure t
  :diminish company-mode
  :commands company-mode
  :hook (prog-mode . company-mode))

(use-package lsp-mode
  :ensure t
  :commands lsp)

(use-package haskell-mode
  :ensure t
  :hook (haskell-mode . haskell-doc-mode)
  :commands haskell-mode
  :init
  (add-hook
   ;; prevent eldoc minibuffer hijacking
   'haskell-mode-hook
   (lambda () (eldoc-mode 0))))

(use-package lsp-haskell
  :when
  (and (executable-find "stack")
       (executable-find
        "haskell-language-server-wrapper"))
  :hook
  ((haskell-mode . lsp)
   (haskell-literate-mode . lsp)))
</code></pre>
<h1>create &#x26; configure new stack project</h1>
<p>to create a new project that is compatible with this setup, we can use stack:</p>
<p><code>$ stack new hello-hs new-template</code></p>
<p>this will create a new directory, named <strong>hello-hs</strong>, containing a stack project that you can fill with haskell goodness. next step is to set the stack ghc resolver to the latest version that is compatible with the version of <strong>haskell-language-server</strong> that was previously installed. at the time of writing this, the latest version of the language server i could install was <em>8.10.3</em>, so i specified this in my <strong>./stack.yaml</strong> inside the newly created project:</p>
<pre><code class="language-yaml">packages:
- .
resolver: ghc-8.10.3
</code></pre>
<p>once you've done this, cd to the root of the project and run</p>
<p><code>$ stack build</code></p>
<p>to automatically install an isolated ghc of the required version. it may seem like we are completely done, but there is one more step, configuring <strong>./hie.yaml</strong>. due to this being just a basic guide, and also that i don't know that much about it than you do, i will only supply a basic hie.yaml, as follows:</p>
<pre><code class="language-yaml">cradle:
  stack:
    - path: "./app"
      component: "hello-hs"
    - path: "./src"
      component: "hello-hs:lib"
    - path: "./test"
      component: "hello-hs:test:hello-hs-test"
</code></pre>
<p>this file advises the language server of the project structure so that it can provide features like go-to-definition, refactoring, and linting. i believe that this step will be added to the language server itself at some point as well so it might not be worth covering it in much detail. after creating this file, you should be able to load up Main.hs/Lib.hs/Spec.hs and start programming modern haskell.</p>
<p>i hope this setup starts breaking down the haskell confusion barrier for you so that you can learn what this eye-opening language has to offer, as opposed to just listening about others talk about it.</p>
<p>-jared</p>
</div></article></main><div class="layout_backToHome__1vZsp"><a href="/blog">‚Üê Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"emacs-haskell-lsp-environment","contentHtml":"\u003cp\u003eas i said before, there would be many posts about emacs and this is no exception. in this iteration, we are looking at haskell language server protocol integration. as i am currently, and always will be, learning haskell extremely slowly, i figured it necessary to leverage my experience with emacs, lsp, and gnu/linux to reap the benefits of the haskell community's ide integration efforts.\u003c/p\u003e\n\u003ch1\u003eterms\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://github.com/microsoft/language-server-protocol\"\u003elsp\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eshort for \u003cem\u003elanguage server protocol\u003c/em\u003e. this is a standard for implementing a language server for a given language. it defines how to create a rest server which understands its implementing language (whether it be haskell, java, c++, scala, or what have you) and accepts queries which return information which can aid in the development process.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://www.haskell.org\"\u003ehaskell\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003enamed after logicial haskell curry, haskell is a general-purpose, statically-typed, \u0026#x26; purely-functional programming language which touts most of the recent innovations in programming and is a consistent source of good ideas for other languages to copy from.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://www.gnu.org/software/emacs/manual/html_node/emacs/Modes.html\"\u003emode\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ean operating mode for emacs which is enabled upon opening a buffer. a mode usually offers a set of functionality that is useful for the type of buffer that was opened. for example, when opening a \u003cem\u003e*.hs\u003c/em\u003e file, \u003cstrong\u003ehaskell-mode\u003c/strong\u003e is started.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://www.gnu.org/software/emacs/manual/html_node/elisp/Setting-Hooks.html\"\u003ehook\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ean unordered list of elisp functions which run when a particular \u003cem\u003emode\u003c/em\u003e is enabled. for example, when \u003cem\u003ehaskell-mode\u003c/em\u003e, \u003cstrong\u003ehaskell-mode-hook\u003c/strong\u003e is executed.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://github.com/emacs-lsp/lsp-mode\"\u003elsp-mode\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea client library for emacs which interacts with servers which implement the language server protocol.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://github.com/jwiegley/use-package\"\u003euse-package\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea set of elisp functions and macros which makes it easy to lazy-load elisp packages with particular configurations. while it is completely optional, loading elisp packages all at once can be quite time complex and cause very slow start-up time. use of this is very much advised as it will future proof your configurations.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003escope\u003c/h1\u003e\n\u003cp\u003eas was said in my previous \u003ca href=\"/blog/posts/emacs-scala-env\"\u003escala-lsp post\u003c/a\u003e, in order to keep this short, i will only be going over the setup of \u003cem\u003euse-package\u003c/em\u003e, \u003cem\u003elsp-mode\u003c/em\u003e, and the operating system configurations required to make a elegant development environment. if you would like to know more about emacs, please check out the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://github.com/lagooned/emacs\"\u003eje/emacs\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethe configuration that i currently use. it is heavily inspired by \u003cem\u003e\u003ca href=\"https://www.spacemacs.org\"\u003espacemacs\u003c/a\u003e\u003c/em\u003e and \u003cem\u003e\u003ca href=\"https://github.com/hlissner/doom-emacs\"\u003edoom-emacs\u003c/a\u003e\u003c/em\u003e. please feel free to copy stuff out of my config or raise a pr, id be happy to have a look at it.\u003c/li\u003e\n\u003cli\u003ehere you can find the configuration as i implemented it, in terms of my own configuration setup, please feel free to use this as a reference\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://sanemacs.com\"\u003esanemacs\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eprovides a good set of sane defaults\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://github.com/emacs-tw/awesome-emacs\"\u003eawesome emacs\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea great, frequently updated place to look for and learn about more packages to add to your emacs configuration.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003einstall binaries\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.haskellstack.org/en/stable/README/#the-haskell-tool-stack\"\u003estack\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003efollow the guide for this and make sure stack is in your \u003cstrong\u003euser-wide ~/.profile $PATH\u003c/strong\u003e (see the guide \u003ca href=\"https://stackabuse.com/how-to-permanently-set-path-in-linux/#usingaprofilefiletosetyourpath\"\u003ehere\u003c/a\u003e for help) so that emacs can see it\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/haskell/haskell-language-server\"\u003ehaskell-language-server\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003eeither build from source or download the pre-compiled binaries; again making sure it is in your \u003cstrong\u003euser-wide ~/.profile $PATH\u003c/strong\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003euse-package: what do?\u003c/h1\u003e\n\u003cp\u003ei previously went over the syntax for \u003cstrong\u003euse-package\u003c/strong\u003e \u003cstrong\u003e\u003ca href=\"/blog/posts/emacs-scala-env#using-use-package\"\u003ehere\u003c/a\u003e\u003c/strong\u003e, as well as the initial \u003cstrong\u003epackage.el\u003c/strong\u003e setup \u003cstrong\u003e\u003ca href=\"/blog/posts/emacs-scala-env#setting-up-package-el\"\u003ehere\u003c/a\u003e\u003c/strong\u003e. perform both of these on your local machine to continue.\u003c/p\u003e\n\u003ch1\u003esetting up lsp\u003c/h1\u003e\n\u003cp\u003ewith your init.el setup to handle packages, you can now add the following in order to finish the emacs portion of the setup\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-elisp\"\u003e(use-package company\n  :ensure t\n  :diminish company-mode\n  :commands company-mode\n  :hook (prog-mode . company-mode))\n\n(use-package lsp-mode\n  :ensure t\n  :commands lsp)\n\n(use-package haskell-mode\n  :ensure t\n  :hook (haskell-mode . haskell-doc-mode)\n  :commands haskell-mode\n  :init\n  (add-hook\n   ;; prevent eldoc minibuffer hijacking\n   'haskell-mode-hook\n   (lambda () (eldoc-mode 0))))\n\n(use-package lsp-haskell\n  :when\n  (and (executable-find \"stack\")\n       (executable-find\n        \"haskell-language-server-wrapper\"))\n  :hook\n  ((haskell-mode . lsp)\n   (haskell-literate-mode . lsp)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003ecreate \u0026#x26; configure new stack project\u003c/h1\u003e\n\u003cp\u003eto create a new project that is compatible with this setup, we can use stack:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$ stack new hello-hs new-template\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003ethis will create a new directory, named \u003cstrong\u003ehello-hs\u003c/strong\u003e, containing a stack project that you can fill with haskell goodness. next step is to set the stack ghc resolver to the latest version that is compatible with the version of \u003cstrong\u003ehaskell-language-server\u003c/strong\u003e that was previously installed. at the time of writing this, the latest version of the language server i could install was \u003cem\u003e8.10.3\u003c/em\u003e, so i specified this in my \u003cstrong\u003e./stack.yaml\u003c/strong\u003e inside the newly created project:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003epackages:\n- .\nresolver: ghc-8.10.3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eonce you've done this, cd to the root of the project and run\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$ stack build\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eto automatically install an isolated ghc of the required version. it may seem like we are completely done, but there is one more step, configuring \u003cstrong\u003e./hie.yaml\u003c/strong\u003e. due to this being just a basic guide, and also that i don't know that much about it than you do, i will only supply a basic hie.yaml, as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003ecradle:\n  stack:\n    - path: \"./app\"\n      component: \"hello-hs\"\n    - path: \"./src\"\n      component: \"hello-hs:lib\"\n    - path: \"./test\"\n      component: \"hello-hs:test:hello-hs-test\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethis file advises the language server of the project structure so that it can provide features like go-to-definition, refactoring, and linting. i believe that this step will be added to the language server itself at some point as well so it might not be worth covering it in much detail. after creating this file, you should be able to load up Main.hs/Lib.hs/Spec.hs and start programming modern haskell.\u003c/p\u003e\n\u003cp\u003ei hope this setup starts breaking down the haskell confusion barrier for you so that you can learn what this eye-opening language has to offer, as opposed to just listening about others talk about it.\u003c/p\u003e\n\u003cp\u003e-jared\u003c/p\u003e\n","title":"make haskell less intimidating with emacs \u0026 lsp","date":"2021-03-02"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"emacs-haskell-lsp-environment"},"buildId":"8Znw76poXjc-Zx-jni9wa","assetPrefix":"/blog","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-86038f8325ecf14c2308.js"></script><script src="/blog/_next/static/chunks/main-f094e29a130fd0913879.js" async=""></script><script src="/blog/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/blog/_next/static/chunks/framework.492e6181467ebf2e0a6c.js" async=""></script><script src="/blog/_next/static/chunks/commons.4e446db3eadf18dc2ad0.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-70651e13387bad6b3f4b.js" async=""></script><script src="/blog/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.596cc5897b16dd510190.js" async=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bid%5D-248d96d842634965509c.js" async=""></script><script src="/blog/_next/static/8Znw76poXjc-Zx-jni9wa/_buildManifest.js" async=""></script><script src="/blog/_next/static/8Znw76poXjc-Zx-jni9wa/_ssgManifest.js" async=""></script></body></html>