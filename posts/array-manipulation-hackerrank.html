<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="description" content="a blog by a guy who likes emacs"/><meta property="og:image" content="/blog/images/jared-engler-blog.png"/><meta name="og:title" content="jared.engler.blog"/><meta name="twitter:card" content="summary_large_image"/><title>hackerrank: array manipulation</title><meta name="next-head-count" content="7"/><link rel="preload" href="/blog/_next/static/css/dfd64abbb58af9f5d7f8.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/dfd64abbb58af9f5d7f8.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/9eb0ab91ec5bd9812a2e.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/9eb0ab91ec5bd9812a2e.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/main-f094e29a130fd0913879.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework.492e6181467ebf2e0a6c.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons.4e446db3eadf18dc2ad0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-70651e13387bad6b3f4b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.d4a3db8613b49501ab76.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/posts/%5Bid%5D-248d96d842634965509c.js" as="script"/></head><body><div id="__next"><div class="layout_container__2t4v2"><header class="layout_header__2rhWq"><a href="/blog"><img src="/blog/images/me-centered-better.png" class="layout_headerImage__2h5On utils_borderCircle__13qdJ" alt="jared.engler"/></a><h2 class="utils_headingLg__de7p0"><a class="utils_colorInherit__3Gudf" href="/blog">jared.engler</a></h2></header><main><article><h1 class="utils_headingXl__1XecN">hackerrank: array manipulation</h1><div class="utils_lightText__12Ckm"><time dateTime="2021-01-13">January 13, 2021</time></div><div class="utils_content__zjeg5"><p>hey y'all. as part of my attempt to stay up-to-date on programming, as well as increase my confidence for interviews, i've been doing the hackerrank <a href="https://www.hackerrank.com/interview/interview-preparation-kit">interview prep kit</a> series. one problem in particular caught my eye, and after solving it sub-optimally, i sought the best solution and learned some cool things along the way and connected it to my functional programming knowledge.</p>
<h1>the problem</h1>
<p><a href="https://www.hackerrank.com/challenges/crush/problem">array manipulation</a>'s problem statement is as such:</p>
<ol>
<li>take a zeroed integer array of size n</li>
<li>process a list of queries which transform the array</li>
<li>then find the maximum value within the array</li>
</ol>
<p>the list of queries are of the form:</p>
<pre><code>a0 b0 k0
a1 b1 k1
a2 b2 k2
...
</code></pre>
<p>where a is the start index, b is the end index, and k is the number to add to the range of integers in the zerod array.</p>
<h1>the naive solution</h1>
<p>when i initially approached this problem, it seemed easy enough; i implemented the solution and passed the initial test cases.</p>
<pre><code class="language-java">static long arrayManipulation(int n, int[][] q) {
    long[] arr = new long[n];
    long max = -1;
    for (int i = 0; i &#x3C; q.length; i++) {
        for (int j = q[i][0]; j &#x3C; q[i][1]; j++) {
            long val = js[j] + q[j][2];
            if (val > max) max = val;
            js[j] = val;
        }
    }
    return max;
}
</code></pre>
<p>now, come on... this isn't a terrible solution, it's actually pretty elegant; i'm even calculating the maximum value whilst performing the array manipulation. this implementation has a big problem, however. it falls over when the size of the array and queries gets huge, as the nested for loop makes the worst-case complexity <strong>O( n * m )</strong> where <strong>n</strong> is the number of queries, and <strong>m</strong> is the maximum value of <strong>b<sub>n</sub> - a<sub>n</sub></strong>.</p>
<h1>the optimal solution</h1>
<p>in order to fully appreciate the optimal solution, there is a very cool concept at the core of functional programming that is at the core of this solution: <strong>fold</strong>.</p>
<h2>the fold</h2>
<p>a fold is not some crazy dance move, it's a <em>function</em>. the whole idea of functional programming is that highly complex operations can be broken down into compositions of simple, named transformations. this concept is similar the purpose of object oriented design patterns; it gives programmers a <strong>vocabulary</strong>, which is the most important part of computer science as it lets you discuss solutions.</p>
<p>a fold is result of the following expression when built from a list, when done with the addition operator:</p>
<pre><code>foldl (+) 0 [1,2,3,4,5] => (((((0+1)+2)+3)+4)+5) => 15
foldr (+) 0 [1,2,3,4,5] => (1+(2+(3+(4+(5+0))))) => 15
</code></pre>
<p>when the operator you use is communative, this has the effect of replacing the commas in a list definition with the operator. this is a more specific version of a <strong>reduce</strong> which is found in most langauges. here is an example of using both a left and right fold with a list of strings and the concatination operation:</p>
<pre><code>foldl (++) "" ["1","2","3","4","5"] => "54321"
foldr (++) "" ["1","2","3","4","5"] => "12345"
</code></pre>
<p>as you can see using this can be very useful for concicely reducing a list to a single value in a particular order</p>
<p>here are the definitions in haskell:</p>
<pre><code class="language-haskell">foldl f z [] = z
foldl f z (x:xs) = foldl f (f z x) xs

foldr f z [] = z
foldr f z (x:xs) = f x (foldr f z xs)
</code></pre>
<h2>from fold to scan</h2>
<p>the reason i've introduced the fold is because it is a good segue into its sister function, the <strong>scan</strong>. a scan is similar to a fold, but instead of reducing the list to a single value, it reduces it into a list of the successive values created by doing the folding operation:</p>
<pre><code>scanl (+) 0 [1,2,3] => [0+1,((0+1)+2),(((0+1)+2)+3)] => [1,3,6]
scanl (+) 0 [1,2,3] => [0+1,(0+(1+2)),(0+(1+(2+3)))] => [1,3,6]
</code></pre>
<p>this function may look quite innoquous, but it is in fact the key to optimizing the array manipulation problem.</p>
<p>here's its haskell definition for completeness:</p>
<pre><code class="language-haskell">scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl = scanlGo
  where
    scanlGo :: (b -> a -> b) -> b -> [a] -> [b]
    scanlGo f q ls = q : (case ls of
                          [] -> []
                          x:xs -> scanlGo f (f q x) xs)

scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr _ q0 [] = [q0]
scanr f q0 (x:xs) = f x q : qs
                    where qs@(q:_) = scanr f q0 xs
</code></pre>
<p>you don't really have to understand these, it's just helpful to explore how they are implemented. i found the implementations <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/src/GHC.List.html">here</a>.</p>
<h1>the array manipulation</h1>
<p>the complexity of the array manipulation step of the original problem can be reduced by utilizing the scan via the following observation:</p>
<pre><code>scanl (+) 0 [0,0,1,0,0,0,0,-1,0,0] => [0,0,1,1,1,1,1,1,0,0]
scanr (+) 0 [0,0,-1,0,0,0,0,1,0,0] => [0,0,1,1,1,1,1,1,0,0]
</code></pre>
<p>this is huge<sup>tm</sup>, as it shows that we can use this scan operation to remove the inner for loop from the naive solution. this is the final implementation in java:</p>
<pre><code class="language-java">static long arrayManipulation(int n, int[][] queries) {
    long[] ns = new long[n+2];
    for (int i = 0; i &#x3C; queries.length; i++) {
        int a = queries[i][0];
        int b = queries[i][1];
        int k = queries[i][2];
        ns[a-1] = ns[a-1]+k;
        ns[b] = ns[b]-k;
    }
    long max = -1l;
    for (int i = 0; i &#x3C; n; i++) {
        ns[i+1] = ns[i]+ns[i+1];
        if (ns[i] > max) max = ns[i];
    }
    return max;
}
</code></pre>
<p>also, to fit with our functional programming knowledge, here is my implementation in scala:</p>
<pre><code class="language-scala">object ArrayManipulation extends App {

  val n = 10

  val queries = List(
    (1,10,1),
    (2,9,1),
    (3,8,1),
    (4,7,1),
    (5,6,1)
  )

  println(
    queries
      .map(q => (-1 + q._1, -1 + q._2, a._3))
      .map(zeroIndexedQ => List.tabulate(n) { i =>
        i match {
          case zeroIndexedQ._1 => zeroIndexedQ._3
          case zeroIndexedQ._2 => -(zeroIndexedQ._3)
          case _ => 0
        }
      })
      .fold(List.tabulate(n)(i => 0)) { (acc, e) =>
        acc.zip(e).map(zipped => zipped._1 + zipped._2)
      }
      .scan(0)(_ + _)
      .max)

}
</code></pre>
<p>give this one a try in your favorite language :)</p>
<p>-jared</p>
</div></article></main><div class="layout_backToHome__1vZsp"><a href="/blog">‚Üê Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"array-manipulation-hackerrank","contentHtml":"\u003cp\u003ehey y'all. as part of my attempt to stay up-to-date on programming, as well as increase my confidence for interviews, i've been doing the hackerrank \u003ca href=\"https://www.hackerrank.com/interview/interview-preparation-kit\"\u003einterview prep kit\u003c/a\u003e series. one problem in particular caught my eye, and after solving it sub-optimally, i sought the best solution and learned some cool things along the way and connected it to my functional programming knowledge.\u003c/p\u003e\n\u003ch1\u003ethe problem\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.hackerrank.com/challenges/crush/problem\"\u003earray manipulation\u003c/a\u003e's problem statement is as such:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003etake a zeroed integer array of size n\u003c/li\u003e\n\u003cli\u003eprocess a list of queries which transform the array\u003c/li\u003e\n\u003cli\u003ethen find the maximum value within the array\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003ethe list of queries are of the form:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ea0 b0 k0\na1 b1 k1\na2 b2 k2\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere a is the start index, b is the end index, and k is the number to add to the range of integers in the zerod array.\u003c/p\u003e\n\u003ch1\u003ethe naive solution\u003c/h1\u003e\n\u003cp\u003ewhen i initially approached this problem, it seemed easy enough; i implemented the solution and passed the initial test cases.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003estatic long arrayManipulation(int n, int[][] q) {\n    long[] arr = new long[n];\n    long max = -1;\n    for (int i = 0; i \u0026#x3C; q.length; i++) {\n        for (int j = q[i][0]; j \u0026#x3C; q[i][1]; j++) {\n            long val = js[j] + q[j][2];\n            if (val \u003e max) max = val;\n            js[j] = val;\n        }\n    }\n    return max;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enow, come on... this isn't a terrible solution, it's actually pretty elegant; i'm even calculating the maximum value whilst performing the array manipulation. this implementation has a big problem, however. it falls over when the size of the array and queries gets huge, as the nested for loop makes the worst-case complexity \u003cstrong\u003eO( n * m )\u003c/strong\u003e where \u003cstrong\u003en\u003c/strong\u003e is the number of queries, and \u003cstrong\u003em\u003c/strong\u003e is the maximum value of \u003cstrong\u003eb\u003csub\u003en\u003c/sub\u003e - a\u003csub\u003en\u003c/sub\u003e\u003c/strong\u003e.\u003c/p\u003e\n\u003ch1\u003ethe optimal solution\u003c/h1\u003e\n\u003cp\u003ein order to fully appreciate the optimal solution, there is a very cool concept at the core of functional programming that is at the core of this solution: \u003cstrong\u003efold\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2\u003ethe fold\u003c/h2\u003e\n\u003cp\u003ea fold is not some crazy dance move, it's a \u003cem\u003efunction\u003c/em\u003e. the whole idea of functional programming is that highly complex operations can be broken down into compositions of simple, named transformations. this concept is similar the purpose of object oriented design patterns; it gives programmers a \u003cstrong\u003evocabulary\u003c/strong\u003e, which is the most important part of computer science as it lets you discuss solutions.\u003c/p\u003e\n\u003cp\u003ea fold is result of the following expression when built from a list, when done with the addition operator:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efoldl (+) 0 [1,2,3,4,5] =\u003e (((((0+1)+2)+3)+4)+5) =\u003e 15\nfoldr (+) 0 [1,2,3,4,5] =\u003e (1+(2+(3+(4+(5+0))))) =\u003e 15\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhen the operator you use is communative, this has the effect of replacing the commas in a list definition with the operator. this is a more specific version of a \u003cstrong\u003ereduce\u003c/strong\u003e which is found in most langauges. here is an example of using both a left and right fold with a list of strings and the concatination operation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efoldl (++) \"\" [\"1\",\"2\",\"3\",\"4\",\"5\"] =\u003e \"54321\"\nfoldr (++) \"\" [\"1\",\"2\",\"3\",\"4\",\"5\"] =\u003e \"12345\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eas you can see using this can be very useful for concicely reducing a list to a single value in a particular order\u003c/p\u003e\n\u003cp\u003ehere are the definitions in haskell:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-haskell\"\u003efoldl f z [] = z\nfoldl f z (x:xs) = foldl f (f z x) xs\n\nfoldr f z [] = z\nfoldr f z (x:xs) = f x (foldr f z xs)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003efrom fold to scan\u003c/h2\u003e\n\u003cp\u003ethe reason i've introduced the fold is because it is a good segue into its sister function, the \u003cstrong\u003escan\u003c/strong\u003e. a scan is similar to a fold, but instead of reducing the list to a single value, it reduces it into a list of the successive values created by doing the folding operation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003escanl (+) 0 [1,2,3] =\u003e [0+1,((0+1)+2),(((0+1)+2)+3)] =\u003e [1,3,6]\nscanl (+) 0 [1,2,3] =\u003e [0+1,(0+(1+2)),(0+(1+(2+3)))] =\u003e [1,3,6]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethis function may look quite innoquous, but it is in fact the key to optimizing the array manipulation problem.\u003c/p\u003e\n\u003cp\u003ehere's its haskell definition for completeness:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-haskell\"\u003escanl :: (b -\u003e a -\u003e b) -\u003e b -\u003e [a] -\u003e [b]\nscanl = scanlGo\n  where\n    scanlGo :: (b -\u003e a -\u003e b) -\u003e b -\u003e [a] -\u003e [b]\n    scanlGo f q ls = q : (case ls of\n                          [] -\u003e []\n                          x:xs -\u003e scanlGo f (f q x) xs)\n\nscanr :: (a -\u003e b -\u003e b) -\u003e b -\u003e [a] -\u003e [b]\nscanr _ q0 [] = [q0]\nscanr f q0 (x:xs) = f x q : qs\n                    where qs@(q:_) = scanr f q0 xs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eyou don't really have to understand these, it's just helpful to explore how they are implemented. i found the implementations \u003ca href=\"https://hackage.haskell.org/package/base-4.14.1.0/docs/src/GHC.List.html\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003ch1\u003ethe array manipulation\u003c/h1\u003e\n\u003cp\u003ethe complexity of the array manipulation step of the original problem can be reduced by utilizing the scan via the following observation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003escanl (+) 0 [0,0,1,0,0,0,0,-1,0,0] =\u003e [0,0,1,1,1,1,1,1,0,0]\nscanr (+) 0 [0,0,-1,0,0,0,0,1,0,0] =\u003e [0,0,1,1,1,1,1,1,0,0]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethis is huge\u003csup\u003etm\u003c/sup\u003e, as it shows that we can use this scan operation to remove the inner for loop from the naive solution. this is the final implementation in java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003estatic long arrayManipulation(int n, int[][] queries) {\n    long[] ns = new long[n+2];\n    for (int i = 0; i \u0026#x3C; queries.length; i++) {\n        int a = queries[i][0];\n        int b = queries[i][1];\n        int k = queries[i][2];\n        ns[a-1] = ns[a-1]+k;\n        ns[b] = ns[b]-k;\n    }\n    long max = -1l;\n    for (int i = 0; i \u0026#x3C; n; i++) {\n        ns[i+1] = ns[i]+ns[i+1];\n        if (ns[i] \u003e max) max = ns[i];\n    }\n    return max;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ealso, to fit with our functional programming knowledge, here is my implementation in scala:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-scala\"\u003eobject ArrayManipulation extends App {\n\n  val n = 10\n\n  val queries = List(\n    (1,10,1),\n    (2,9,1),\n    (3,8,1),\n    (4,7,1),\n    (5,6,1)\n  )\n\n  println(\n    queries\n      .map(q =\u003e (-1 + q._1, -1 + q._2, a._3))\n      .map(zeroIndexedQ =\u003e List.tabulate(n) { i =\u003e\n        i match {\n          case zeroIndexedQ._1 =\u003e zeroIndexedQ._3\n          case zeroIndexedQ._2 =\u003e -(zeroIndexedQ._3)\n          case _ =\u003e 0\n        }\n      })\n      .fold(List.tabulate(n)(i =\u003e 0)) { (acc, e) =\u003e\n        acc.zip(e).map(zipped =\u003e zipped._1 + zipped._2)\n      }\n      .scan(0)(_ + _)\n      .max)\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003egive this one a try in your favorite language :)\u003c/p\u003e\n\u003cp\u003e-jared\u003c/p\u003e\n","title":"hackerrank: array manipulation","date":"2021-01-13"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"array-manipulation-hackerrank"},"buildId":"rYb3Nc1C-BSbDG5d2vI0B","assetPrefix":"/blog","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-86038f8325ecf14c2308.js"></script><script src="/blog/_next/static/chunks/main-f094e29a130fd0913879.js" async=""></script><script src="/blog/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/blog/_next/static/chunks/framework.492e6181467ebf2e0a6c.js" async=""></script><script src="/blog/_next/static/chunks/commons.4e446db3eadf18dc2ad0.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-70651e13387bad6b3f4b.js" async=""></script><script src="/blog/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.d4a3db8613b49501ab76.js" async=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bid%5D-248d96d842634965509c.js" async=""></script><script src="/blog/_next/static/rYb3Nc1C-BSbDG5d2vI0B/_buildManifest.js" async=""></script><script src="/blog/_next/static/rYb3Nc1C-BSbDG5d2vI0B/_ssgManifest.js" async=""></script></body></html>